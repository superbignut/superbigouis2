> The Programmable Interval Timer (PIT) chip (Intel 8253/8254) basically consists of an oscillator, a prescaler and 3 independent frequency dividers. Each frequency divider has an output, which is used to allow the timer to control external circuitry (for example, IRQ 0).


大概的意思是，8253 PIT 芯片有三个通道，也就有三个输出，第一个用来控制中断， 第二个用逐渐被弃用了，第三个被用来做扬声器发声


+ Channel 0
> The output from PIT channel 0 is connected to the PIC chip, so that it generates an "IRQ 0". Typically during boot the BIOS sets channel 0 with a count of 65535 or 0 (which translates to 65536), which gives an output frequency of 18.2065 Hz (or an IRQ every 54.9254 ms). Channel 0 is probably the most useful PIT channel, as it is the only channel that is connected to an IRQ. It can be used to generate an infinte series of "timer ticks" at a frequency of your choice (as long as it is higher than 18 Hz), or to generate single CPU interrupts (in "one shot" mode) after programmable short delays (less than an 18th of a second).

> When choosing an operating mode, below, it is useful to remember that the IRQ0 is generated by the rising edge of the Channel 0 output voltage (ie. the transition from "low" to "high", only).

+ Channel 1
> The output for PIT channel 1 was once used (in conjunction with the DMA controller's channel 0) for refreshing the DRAM (Dynamic Random Access Memory) or RAM. Typically, each bit in RAM consists of a capacitor which holds a tiny charge representing the state of that bit, however (due to leakage) these capacitors need to be "refreshed" periodically so that they don't forget their state.

> On later machines, the DRAM refresh is done with dedicated hardware and the PIT (and DMA controller) is no longer used. On modern computers where the functionality of the PIT is implemented in a large scale integrated circuit, PIT channel 1 is no longer usable and may not be implemented at all.

+ Channel 2
> The output of PIT channel 2 is connected to the PC speaker, so the frequency of the output determines the frequency of the sound produced by the speaker. This is the only channel where the gate input can be controlled by software (via bit 0 of I/O port 0x61), and the only channel where its output (a high or low voltage) can be read by software (via bit 5 of I/O port 0x61). Details of how to program the PC speaker can be found here.

    + 这里提到了这个 gate input/pin 的作用


I/O port     Usage
0x40         Channel 0 data port (read/write)
0x41         Channel 1 data port (read/write)
0x42         Channel 2 data port (read/write)
0x43         Mode/Command register (write only, a read is ignored)




Bits         Usage
6 and 7      Select channel :
                0 0 = Channel 0
                0 1 = Channel 1
                1 0 = Channel 2
                1 1 = Read-back command (8254 only)
4 and 5      Access mode :
                0 0 = Latch count value command     ;  这个
                0 1 = Access mode: lobyte only
                1 0 = Access mode: hibyte only
                1 1 = Access mode: lobyte/hibyte
1 to 3       Operating mode :
                0 0 0 = Mode 0 (interrupt on terminal count)
                0 0 1 = Mode 1 (hardware re-triggerable one-shot)
                0 1 0 = Mode 2 (rate generator)
                0 1 1 = Mode 3 (square wave generator)
                1 0 0 = Mode 4 (software triggered strobe)
                1 0 1 = Mode 5 (hardware triggered strobe)
                1 1 0 = Mode 2 (rate generator, same as 010b)
                1 1 1 = Mode 3 (square wave generator, same as 011b)
0            BCD/Binary mode: 0 = 16-bit binary, 1 = four-digit BCD


Operating mode:
    
+ Mode 0 – Interrupt On Terminal Count

    For this mode, when the mode/command register is written the output signal goes low and the PIT waits for the reload register to be set by software, to begin the countdown. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count (if the gate input is high on the preceding rising edge of the input signal).

    When the current count decrements from one to zero, the output goes high and remains high until another mode/command register is written or the reload register is set again. The current count will wrap around to 0xFFFF (or 0x9999 in BCD mode) and continue to decrement until the mode/command register or the reload register are set, however this will not affect the output pin state.

    The reload value can be changed at any time. In "lobyte/hibyte" access mode counting will stop when the first byte of the reload value is set. Once the full reload value is set (in any access mode), the next falling edge of the (1.193182 MHz) input signal will cause the new reload value to be copied into the current count, and the countdown will continue from the new value.

    Note: despite the misleading name of this mode, it only generates interrupts on channel 0.

    这里有个问题，当计数器减到0 的时候，难道还需要自己手动再次去 加载计数值吗

+ Mode 1 – Hardware Re-triggerable One-shot
+ Mode 2 – Rate Generator

    This mode operates as a frequency divider.

    When the mode/command register is written the output signal goes high and the PIT waits for the reload register to be set by software. After the reload register has been set, the current count will be set to the reload value on the next falling edge of the (1.193182 MHz) input signal. Subsequent falling edges of the input signal will decrement the current count (if the gate input is high on the preceding rising edge of the input signal).

    When the current count decrements from two to one, the output goes low, and on the next falling edge of the (1.193182 MHz) input signal it will go high again and the current count will be set to the reload value and counting will continue.

    If the gate input goes low, counting stops and the output goes high immediately. Once the gate input has returned high, the next falling edge on input signal will cause the current count to be set to the reload value and operation will continue.

    这里提到的这个 gate pin 如果去看原手册的话， 这个引脚设计的目的是为了同步芯片的，但osdev 中又说 01通道并没有使用这个引脚，并且感觉 counting stops 说的也不太对，就先不管了

    The reload value can be changed at any time, however the new value will not affect the current count until the current count is reloaded (when it is decreased from two to one, or the gate input going low then high). When this occurs counting will continue using the new reload value.

    A reload value (or divisor) of one must not be used with this mode.

    This mode creates a high output signal that drops low for one input signal cycle (0.8381 uS), which is too fast to make a difference to the PC speaker (see mode 3). For this reason mode 2 is useless for producing sounds with PIT channel 2.

    Typically, OSes and BIOSes use mode 3 (see below) for PIT channel 0 to generate IRQ 0 timer ticks, but some use mode 2 instead, to gain frequency accuracy (frequency = 1193182 / reload_value Hz).

    所以这个模式就是，一直高电平，只有当计数器减到0 的时候 会低电平一会， 然后又会重新加载计数值

    然后这里应该是 结合 8259 配置的ICW1的边沿触发中断，每当（不知道是高切低，还是低切高）就会触发中断

        这里看了一下，8259的手册：
        > The powerful features of the 8259A in a microcomputer system are its programmability and the interrupt routine addressing capability. The latter allows
        direct or indirect jumping to the specific interrupt routine requested without any polling of the interrupting
        devices. The normal sequence of events during an
        interrupt depends on the type of CPU being used.
        The events occur as follows in an MCS-80/85 system:

          1. One or more of the INTERRUPT REQUEST lines
              (IR7 –0) are raised high, setting the corresponding IRR bit(s).
              
          2. The 8259A evaluates these requests, and sends
              an INT to the CPU, if appropriate

        所以如果8259配置成了 边沿触发模式的话，应该就是 低电平切高电平的时候会触发中断喽

+ Mode 3 – Square Wave Generator
+ Mode 4 – Software Triggered Strobe
+ Mode 5 – Hardware Triggered Strobe


0 0 = Latch count value command     ;  这个锁存模式用来将读取数据时的data 保存起来，读完之后再去变化：

+ Counter Latch Command

> To prevent the current count from being updated, it is possible to "latch" a PIT channel using the latch command. To do this, send the value CC000000 (in binary) to the mode/command register (I/O port 0x43), where 'CC' corresponds to the channel number. When the latch command has been sent, the current count is copied into an internal "latch register" which can then be read via the data port corresponding to the selected channel (I/O ports 0x40 to 0x42). The value kept in the latch register remains the same until it has been fully read, or until a new mode/command register is written.

> The main benefit of the latch command is that it allows both bytes of the current count to be read without inconsistencies. For example, if you didn't use the latch command, then the current count may decrease from 0x0200 to 0x01FF after you've read the low byte but before you've read the high byte, so that your software thinks the counter was 0x0100 instead of 0x0200 (or 0x01FF).


今天的代码看到了一种新的写法，先读后写， 以前好像也见过，但是每次见到都觉得 异常舒服

    + 先把屏蔽字读出来
    + 再把修改后的屏蔽字写进去

```cpp
void set_hardware_interrupt_mask(uint32_t irq, bool if_enable)
{
    assert(irq >=0 && irq < 16);
    uint32_t _port;
    uint8_t _data;

    if(irq < 8)
    {
        _port = PIC_8259_MASTER_DATA;
    }
    else
    {
        _port = PIC_8259_SLAVE_DATA;
        irq -= 8;                       //  这时需要去屏蔽 8259从片
    }

    _data = 1 << irq;

    if(if_enable)
    {
        write_byte_to_port(_port, read_byte_from_port(_port) & (~_data));   //  先读出来，再去写， 可以防止覆盖已有的设置
    }
    else
    {
        write_byte_to_port(_port, read_byte_from_port(_port) | (_data));
    }

}


```



> The speaker itself has two possible positions, "in" and "out". This position can be set through bit 1 of port 0x61 on the Keyboard Controller. If this bit is set (=1), the speaker will move to the "out" position, if it is cleared (=0) then the speaker will move to the "in" position. Moving in and out repeatedly produces audible tones if the speed of repetition (the frequency) is within the range the speaker can reproduce and the human ear can hear. Also, a single movement in or out makes a click sound because it's so fast. Thus, a frequency which is too low to be heard as a tone may be heard as a rattle or buzz. (In fact, any frequency produced by this system also produces higher frequencies; look up "square wave harmonics" if you're interested.)

最开始还以为是，out的时候就 be， in 的时候就没有声音，结果原来是来回的频率震动发出的声音

> The PC Speaker can be connected directly to the output of timer number 2 on the Programmable Interval Timer by setting bit 0 of port 0x61 (=1). In this mode, when the timer goes "high" (=1) the speaker will move to the "out" position. Likewise, when the timer goes "low" (=0) the speaker will move to the "in" position. By changing the frequency at which timer 2 "ticks", the PC Speaker can be made to output sound of the same frequency. This mode is very popular because it is easy to program and because it is asynchronous from the rest of the computer's operation, meaning that it takes very little CPU time. It should also be noted that this is the "official" way to program the PC Speaker and, if a sound card is present, should be the only way that the PC Speaker is programmed.


然后在windows上 有些不同，

qemu配置如下：

```makefile
qemu: $(BUILD)/master.img
	qemu-system-i386 \
				-m 32M \
				-boot c \
				-drive file=$<,if=ide,index=0,media=disk,format=raw \
				-audiodev dsound,id=audio0 \
				-machine pcspk-audiodev=audio0
```

然后我最开始一直调不出来声音，后来发现是，8253 选哟配置成 Mode 3 – Square Wave Generator 模式 和 最开始的频率模式是不一样的，

并且在 bochs 中 也能 bee 出来， nice.